# Cross-Robot Movement Imitation: FK/IK Pipeline

## Objective

The goal is to make an xArm 7-DOF robot replicate a movement originally performed by a Franka Emika Panda robot. Since the robots have different kinematic structures, a direct joint-angle mapping is not possible. Instead, we use a two-stage pipeline based on Forward Kinematics (FK) and Inverse Kinematics (IK).

## Core Pipeline: A Two-Stage Process

The translation of motion from Franka to xArm is achieved in two sequential stages: Recording and Playback.

### 1. Stage 1: Recording with Forward Kinematics (FK)

This stage captures the desired motion from the Franka robot.

*   **Plan a Path:** First, we use the Franka's MoveIt! configuration to generate a joint-space plan for a desired movement (e.g., moving to a specific target).
*   **Calculate End-Effector Poses:** We then process this joint-space plan. For each set of joint angles in the plan, we apply **Forward Kinematics (FK)** using the Franka's robot model.
*   **Result:** The output of the FK calculation is the precise 3D **pose** (both position and orientation) of the Franka's end-effector. By doing this for the entire plan, we generate a time-ordered sequence of poses. This sequence, which represents the complete end-effector path, is then saved to a file.

### 2. Stage 2: Playback with Inverse Kinematics (IK)

This stage reproduces the captured motion on the xArm robot.

*   **Load the Path:** The playback script begins by loading the saved sequence of end-effector poses.
*   **Calculate Joint Angles with IK:** The script iterates through the sequence of poses. For each pose, it uses the **`ikpy` library** with the xArm's URDF model to perform an **Inverse Kinematics (IK)** calculation.
*   **Result:** This calculation determines the specific joint angles the xArm needs to achieve that end-effector pose. The result is a new joint trajectory, created point-by-point, specifically for the xArm.
*   **Execute:** The final step is to send this new joint trajectory directly to the xArm's `follow_joint_trajectory` action server for execution.

## Decoupled Workflow

This "Record and Playback" model separates the problem into two simple, independent steps.

1.  **Record Franka's Trajectory:**
    *   This step runs a Franka-only simulation to generate and save the end-effector pose file.
    *   `roslaunch franka_recording record_moveit.launch`

2.  **Playback on xArm:**
    *   This step runs an xArm-only simulation, loads the pose file, and executes the motion.
    *   `roslaunch xarm_following playback_ik.launch`

This method ensures a reliable and accurate transfer of motion by focusing on the end-effector's path in 3D space, which is the common language between the two different robots.
